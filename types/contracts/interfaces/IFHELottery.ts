/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../../common";

export interface IFHELotteryInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "COOLING_PERIOD"
      | "ENTRY_FEE"
      | "MAX_NUMBER"
      | "MAX_PLAYERS"
      | "PLATFORM_FEE_BPS"
      | "ROUND_DURATION"
      | "canClaimRefund"
      | "canStartNewRound"
      | "claimRefund"
      | "getCurrentRound"
      | "getPlayerGuesses"
      | "getRoundResults"
      | "getTimeRemaining"
      | "initiateSettlement"
      | "submitGuess"
      | "submitMultipleGuesses"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "GuessSubmitted"
      | "NoWinnerRound"
      | "PlatformFeeCollected"
      | "RefundClaimed"
      | "RoundSettled"
      | "RoundStarted"
      | "WinnerRevealed"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "COOLING_PERIOD",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "ENTRY_FEE", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "MAX_NUMBER",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MAX_PLAYERS",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "PLATFORM_FEE_BPS",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "ROUND_DURATION",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "canClaimRefund",
    values: [BigNumberish, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "canStartNewRound",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "claimRefund",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getCurrentRound",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getPlayerGuesses",
    values: [BigNumberish, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getRoundResults",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getTimeRemaining",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initiateSettlement",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "submitGuess",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "submitMultipleGuesses",
    values: [BytesLike[], BytesLike[]]
  ): string;

  decodeFunctionResult(
    functionFragment: "COOLING_PERIOD",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "ENTRY_FEE", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "MAX_NUMBER", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "MAX_PLAYERS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "PLATFORM_FEE_BPS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "ROUND_DURATION",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "canClaimRefund",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "canStartNewRound",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimRefund",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCurrentRound",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPlayerGuesses",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRoundResults",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTimeRemaining",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initiateSettlement",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "submitGuess",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "submitMultipleGuesses",
    data: BytesLike
  ): Result;
}

export namespace GuessSubmittedEvent {
  export type InputTuple = [
    roundId: BigNumberish,
    player: AddressLike,
    guessIndex: BigNumberish
  ];
  export type OutputTuple = [
    roundId: bigint,
    player: string,
    guessIndex: bigint
  ];
  export interface OutputObject {
    roundId: bigint;
    player: string;
    guessIndex: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace NoWinnerRoundEvent {
  export type InputTuple = [roundId: BigNumberish, luckyNumber: BigNumberish];
  export type OutputTuple = [roundId: bigint, luckyNumber: bigint];
  export interface OutputObject {
    roundId: bigint;
    luckyNumber: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace PlatformFeeCollectedEvent {
  export type InputTuple = [roundId: BigNumberish, amount: BigNumberish];
  export type OutputTuple = [roundId: bigint, amount: bigint];
  export interface OutputObject {
    roundId: bigint;
    amount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace RefundClaimedEvent {
  export type InputTuple = [
    roundId: BigNumberish,
    player: AddressLike,
    amount: BigNumberish
  ];
  export type OutputTuple = [roundId: bigint, player: string, amount: bigint];
  export interface OutputObject {
    roundId: bigint;
    player: string;
    amount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace RoundSettledEvent {
  export type InputTuple = [
    roundId: BigNumberish,
    luckyNumber: BigNumberish,
    winners: AddressLike[],
    payouts: BigNumberish[]
  ];
  export type OutputTuple = [
    roundId: bigint,
    luckyNumber: bigint,
    winners: string[],
    payouts: bigint[]
  ];
  export interface OutputObject {
    roundId: bigint;
    luckyNumber: bigint;
    winners: string[];
    payouts: bigint[];
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace RoundStartedEvent {
  export type InputTuple = [
    roundId: BigNumberish,
    startTime: BigNumberish,
    endTime: BigNumberish
  ];
  export type OutputTuple = [
    roundId: bigint,
    startTime: bigint,
    endTime: bigint
  ];
  export interface OutputObject {
    roundId: bigint;
    startTime: bigint;
    endTime: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace WinnerRevealedEvent {
  export type InputTuple = [
    roundId: BigNumberish,
    winner: AddressLike,
    guess: BigNumberish,
    payout: BigNumberish
  ];
  export type OutputTuple = [
    roundId: bigint,
    winner: string,
    guess: bigint,
    payout: bigint
  ];
  export interface OutputObject {
    roundId: bigint;
    winner: string;
    guess: bigint;
    payout: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface IFHELottery extends BaseContract {
  connect(runner?: ContractRunner | null): IFHELottery;
  waitForDeployment(): Promise<this>;

  interface: IFHELotteryInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  COOLING_PERIOD: TypedContractMethod<[], [bigint], "view">;

  ENTRY_FEE: TypedContractMethod<[], [bigint], "view">;

  MAX_NUMBER: TypedContractMethod<[], [bigint], "view">;

  MAX_PLAYERS: TypedContractMethod<[], [bigint], "view">;

  PLATFORM_FEE_BPS: TypedContractMethod<[], [bigint], "view">;

  ROUND_DURATION: TypedContractMethod<[], [bigint], "view">;

  canClaimRefund: TypedContractMethod<
    [_roundId: BigNumberish, _player: AddressLike],
    [boolean],
    "view"
  >;

  canStartNewRound: TypedContractMethod<[], [boolean], "view">;

  claimRefund: TypedContractMethod<
    [_roundId: BigNumberish],
    [void],
    "nonpayable"
  >;

  getCurrentRound: TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint, bigint, bigint, bigint, boolean] & {
        roundId: bigint;
        startTime: bigint;
        endTime: bigint;
        totalPool: bigint;
        playerCount: bigint;
        guessCount: bigint;
        isSettled: boolean;
      }
    ],
    "view"
  >;

  getPlayerGuesses: TypedContractMethod<
    [_roundId: BigNumberish, _player: AddressLike],
    [[bigint[], bigint] & { guessIndices: bigint[]; contribution: bigint }],
    "view"
  >;

  getRoundResults: TypedContractMethod<
    [_roundId: BigNumberish],
    [
      [boolean, boolean, bigint, string[], bigint[]] & {
        isSettled: boolean;
        hasExactMatch: boolean;
        luckyNumber: bigint;
        winners: string[];
        payouts: bigint[];
      }
    ],
    "view"
  >;

  getTimeRemaining: TypedContractMethod<[], [bigint], "view">;

  initiateSettlement: TypedContractMethod<
    [_roundId: BigNumberish],
    [void],
    "nonpayable"
  >;

  submitGuess: TypedContractMethod<
    [_encryptedGuess: BytesLike, _inputProof: BytesLike],
    [void],
    "payable"
  >;

  submitMultipleGuesses: TypedContractMethod<
    [_encryptedGuesses: BytesLike[], _inputProofs: BytesLike[]],
    [void],
    "payable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "COOLING_PERIOD"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "ENTRY_FEE"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "MAX_NUMBER"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "MAX_PLAYERS"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "PLATFORM_FEE_BPS"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "ROUND_DURATION"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "canClaimRefund"
  ): TypedContractMethod<
    [_roundId: BigNumberish, _player: AddressLike],
    [boolean],
    "view"
  >;
  getFunction(
    nameOrSignature: "canStartNewRound"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "claimRefund"
  ): TypedContractMethod<[_roundId: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "getCurrentRound"
  ): TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint, bigint, bigint, bigint, boolean] & {
        roundId: bigint;
        startTime: bigint;
        endTime: bigint;
        totalPool: bigint;
        playerCount: bigint;
        guessCount: bigint;
        isSettled: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getPlayerGuesses"
  ): TypedContractMethod<
    [_roundId: BigNumberish, _player: AddressLike],
    [[bigint[], bigint] & { guessIndices: bigint[]; contribution: bigint }],
    "view"
  >;
  getFunction(
    nameOrSignature: "getRoundResults"
  ): TypedContractMethod<
    [_roundId: BigNumberish],
    [
      [boolean, boolean, bigint, string[], bigint[]] & {
        isSettled: boolean;
        hasExactMatch: boolean;
        luckyNumber: bigint;
        winners: string[];
        payouts: bigint[];
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getTimeRemaining"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "initiateSettlement"
  ): TypedContractMethod<[_roundId: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "submitGuess"
  ): TypedContractMethod<
    [_encryptedGuess: BytesLike, _inputProof: BytesLike],
    [void],
    "payable"
  >;
  getFunction(
    nameOrSignature: "submitMultipleGuesses"
  ): TypedContractMethod<
    [_encryptedGuesses: BytesLike[], _inputProofs: BytesLike[]],
    [void],
    "payable"
  >;

  getEvent(
    key: "GuessSubmitted"
  ): TypedContractEvent<
    GuessSubmittedEvent.InputTuple,
    GuessSubmittedEvent.OutputTuple,
    GuessSubmittedEvent.OutputObject
  >;
  getEvent(
    key: "NoWinnerRound"
  ): TypedContractEvent<
    NoWinnerRoundEvent.InputTuple,
    NoWinnerRoundEvent.OutputTuple,
    NoWinnerRoundEvent.OutputObject
  >;
  getEvent(
    key: "PlatformFeeCollected"
  ): TypedContractEvent<
    PlatformFeeCollectedEvent.InputTuple,
    PlatformFeeCollectedEvent.OutputTuple,
    PlatformFeeCollectedEvent.OutputObject
  >;
  getEvent(
    key: "RefundClaimed"
  ): TypedContractEvent<
    RefundClaimedEvent.InputTuple,
    RefundClaimedEvent.OutputTuple,
    RefundClaimedEvent.OutputObject
  >;
  getEvent(
    key: "RoundSettled"
  ): TypedContractEvent<
    RoundSettledEvent.InputTuple,
    RoundSettledEvent.OutputTuple,
    RoundSettledEvent.OutputObject
  >;
  getEvent(
    key: "RoundStarted"
  ): TypedContractEvent<
    RoundStartedEvent.InputTuple,
    RoundStartedEvent.OutputTuple,
    RoundStartedEvent.OutputObject
  >;
  getEvent(
    key: "WinnerRevealed"
  ): TypedContractEvent<
    WinnerRevealedEvent.InputTuple,
    WinnerRevealedEvent.OutputTuple,
    WinnerRevealedEvent.OutputObject
  >;

  filters: {
    "GuessSubmitted(uint256,address,uint256)": TypedContractEvent<
      GuessSubmittedEvent.InputTuple,
      GuessSubmittedEvent.OutputTuple,
      GuessSubmittedEvent.OutputObject
    >;
    GuessSubmitted: TypedContractEvent<
      GuessSubmittedEvent.InputTuple,
      GuessSubmittedEvent.OutputTuple,
      GuessSubmittedEvent.OutputObject
    >;

    "NoWinnerRound(uint256,uint8)": TypedContractEvent<
      NoWinnerRoundEvent.InputTuple,
      NoWinnerRoundEvent.OutputTuple,
      NoWinnerRoundEvent.OutputObject
    >;
    NoWinnerRound: TypedContractEvent<
      NoWinnerRoundEvent.InputTuple,
      NoWinnerRoundEvent.OutputTuple,
      NoWinnerRoundEvent.OutputObject
    >;

    "PlatformFeeCollected(uint256,uint256)": TypedContractEvent<
      PlatformFeeCollectedEvent.InputTuple,
      PlatformFeeCollectedEvent.OutputTuple,
      PlatformFeeCollectedEvent.OutputObject
    >;
    PlatformFeeCollected: TypedContractEvent<
      PlatformFeeCollectedEvent.InputTuple,
      PlatformFeeCollectedEvent.OutputTuple,
      PlatformFeeCollectedEvent.OutputObject
    >;

    "RefundClaimed(uint256,address,uint256)": TypedContractEvent<
      RefundClaimedEvent.InputTuple,
      RefundClaimedEvent.OutputTuple,
      RefundClaimedEvent.OutputObject
    >;
    RefundClaimed: TypedContractEvent<
      RefundClaimedEvent.InputTuple,
      RefundClaimedEvent.OutputTuple,
      RefundClaimedEvent.OutputObject
    >;

    "RoundSettled(uint256,uint8,address[],uint256[])": TypedContractEvent<
      RoundSettledEvent.InputTuple,
      RoundSettledEvent.OutputTuple,
      RoundSettledEvent.OutputObject
    >;
    RoundSettled: TypedContractEvent<
      RoundSettledEvent.InputTuple,
      RoundSettledEvent.OutputTuple,
      RoundSettledEvent.OutputObject
    >;

    "RoundStarted(uint256,uint256,uint256)": TypedContractEvent<
      RoundStartedEvent.InputTuple,
      RoundStartedEvent.OutputTuple,
      RoundStartedEvent.OutputObject
    >;
    RoundStarted: TypedContractEvent<
      RoundStartedEvent.InputTuple,
      RoundStartedEvent.OutputTuple,
      RoundStartedEvent.OutputObject
    >;

    "WinnerRevealed(uint256,address,uint8,uint256)": TypedContractEvent<
      WinnerRevealedEvent.InputTuple,
      WinnerRevealedEvent.OutputTuple,
      WinnerRevealedEvent.OutputObject
    >;
    WinnerRevealed: TypedContractEvent<
      WinnerRevealedEvent.InputTuple,
      WinnerRevealedEvent.OutputTuple,
      WinnerRevealedEvent.OutputObject
    >;
  };
}
