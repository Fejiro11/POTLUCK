// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "fhevm/lib/TFHE.sol";
import "fhevm/gateway/GatewayCaller.sol";

/**
 * @title FHELottery
 * @notice A private-by-default lottery using Zama's fully homomorphic encryption.
 * @dev All guesses and the winning number remain encrypted until settlement.
 *      No branching on plaintext values. Privacy and fairness enforced by FHE.
 */
contract FHELottery is GatewayCaller {
    // ============ Constants ============
    uint256 public constant ENTRY_FEE = 0.001 ether;
    uint256 public constant ROUND_DURATION = 10 minutes;
    uint256 public constant COOLING_PERIOD = 10 minutes;
    uint256 public constant MAX_PLAYERS = 60;
    uint256 public constant MAX_NUMBER = 100;
    uint256 public constant PLATFORM_FEE_BPS = 30; // 0.3% = 30 basis points

    // ============ Structs ============
    struct EncryptedGuess {
        address player;
        euint8 encryptedNumber;
        euint8 distance; // Distance from lucky number (computed at settlement)
        uint256 submissionOrder;
        bool isWinner;
        uint8 revealedNumber; // Only set for winners after settlement
    }

    struct Round {
        uint256 roundId;
        uint256 startTime;
        uint256 endTime;
        euint8 encryptedLuckyNumber;
        uint8 revealedLuckyNumber;
        uint256 totalPool;
        uint256 platformFee;
        uint256 playerCount;
        uint256 guessCount;
        uint256 maxWinners;
        bool isSettled;
        bool luckyNumberRevealed;
        bool hasExactMatch;
        address[] winners;
        uint256[] winnerPayouts;
    }

    // ============ State Variables ============
    address public owner;
    address public platformWallet;
    uint256 public currentRoundId;
    
    mapping(uint256 => Round) public rounds;
    mapping(uint256 => EncryptedGuess[]) public roundGuesses;
    mapping(uint256 => mapping(address => uint256[])) public playerGuessIndices;
    mapping(uint256 => mapping(address => bool)) public hasClaimedRefund;
    mapping(uint256 => mapping(address => uint256)) public playerContributions;
    
    // Decryption request tracking
    mapping(uint256 => uint256) public decryptionRequests; // requestId => roundId
    mapping(uint256 => uint256) public guessDecryptionRequests; // requestId => guessIndex (packed with roundId)

    // ============ Events ============
    event RoundStarted(uint256 indexed roundId, uint256 startTime, uint256 endTime);
    event GuessSubmitted(uint256 indexed roundId, address indexed player, uint256 guessIndex);
    event RoundSettled(uint256 indexed roundId, uint8 luckyNumber, address[] winners, uint256[] payouts);
    event NoWinnerRound(uint256 indexed roundId, uint8 luckyNumber);
    event RefundClaimed(uint256 indexed roundId, address indexed player, uint256 amount);
    event PlatformFeeCollected(uint256 indexed roundId, uint256 amount);
    event WinnerRevealed(uint256 indexed roundId, address indexed winner, uint8 guess, uint256 payout);

    // ============ Modifiers ============
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }

    modifier roundActive() {
        Round storage round = rounds[currentRoundId];
        require(block.timestamp >= round.startTime, "Round not started");
        require(block.timestamp < round.endTime, "Round ended");
        require(round.playerCount < MAX_PLAYERS, "Round full");
        _;
    }

    modifier roundEnded(uint256 _roundId) {
        require(block.timestamp >= rounds[_roundId].endTime, "Round not ended");
        _;
    }

    // ============ Constructor ============
    constructor(address _platformWallet) {
        owner = msg.sender;
        platformWallet = _platformWallet;
        _startNewRound();
    }

    // ============ Core Functions ============

    /**
     * @notice Submit an encrypted guess for the current round
     * @param _encryptedGuess The FHE-encrypted guess (0-100)
     * @param _inputProof Proof for the encrypted input
     */
    function submitGuess(
        einput _encryptedGuess,
        bytes calldata _inputProof
    ) external payable roundActive {
        require(msg.value >= ENTRY_FEE, "Insufficient fee");
        
        Round storage round = rounds[currentRoundId];
        
        // Convert input to encrypted uint8
        euint8 encryptedNumber = TFHE.asEuint8(_encryptedGuess, _inputProof);
        
        // Validate guess is within range (0-100) using encrypted comparison
        ebool isValidLow = TFHE.ge(encryptedNumber, TFHE.asEuint8(0));
        ebool isValidHigh = TFHE.le(encryptedNumber, TFHE.asEuint8(MAX_NUMBER));
        ebool isValid = TFHE.and(isValidLow, isValidHigh);
        
        // Clamp to valid range (conditional select based on validity)
        euint8 clampedGuess = TFHE.select(
            isValid,
            encryptedNumber,
            TFHE.asEuint8(0)
        );
        
        // Store the encrypted guess
        uint256 guessIndex = round.guessCount;
        roundGuesses[currentRoundId].push(EncryptedGuess({
            player: msg.sender,
            encryptedNumber: clampedGuess,
            distance: TFHE.asEuint8(255), // Max distance initially
            submissionOrder: guessIndex,
            isWinner: false,
            revealedNumber: 0
        }));
        
        playerGuessIndices[currentRoundId][msg.sender].push(guessIndex);
        
        // Track if this is a new player
        if (playerGuessIndices[currentRoundId][msg.sender].length == 1) {
            round.playerCount++;
        }
        
        round.guessCount++;
        round.totalPool += msg.value;
        playerContributions[currentRoundId][msg.sender] += msg.value;
        
        emit GuessSubmitted(currentRoundId, msg.sender, guessIndex);
        
        // Refund excess ETH
        if (msg.value > ENTRY_FEE) {
            uint256 refund = msg.value - ENTRY_FEE;
            round.totalPool -= refund;
            playerContributions[currentRoundId][msg.sender] -= refund;
            (bool success, ) = msg.sender.call{value: refund}("");
            require(success, "Refund failed");
        }
    }

    /**
     * @notice Submit multiple encrypted guesses in one transaction
     * @param _encryptedGuesses Array of encrypted guesses
     * @param _inputProofs Array of proofs
     */
    function submitMultipleGuesses(
        einput[] calldata _encryptedGuesses,
        bytes[] calldata _inputProofs
    ) external payable roundActive {
        uint256 numGuesses = _encryptedGuesses.length;
        require(numGuesses > 0 && numGuesses <= 10, "Invalid guess count");
        require(_inputProofs.length == numGuesses, "Proof count mismatch");
        require(msg.value >= ENTRY_FEE * numGuesses, "Insufficient fee");
        
        Round storage round = rounds[currentRoundId];
        
        for (uint256 i = 0; i < numGuesses; i++) {
            euint8 encryptedNumber = TFHE.asEuint8(_encryptedGuesses[i], _inputProofs[i]);
            
            ebool isValidLow = TFHE.ge(encryptedNumber, TFHE.asEuint8(0));
            ebool isValidHigh = TFHE.le(encryptedNumber, TFHE.asEuint8(MAX_NUMBER));
            ebool isValid = TFHE.and(isValidLow, isValidHigh);
            
            euint8 clampedGuess = TFHE.select(
                isValid,
                encryptedNumber,
                TFHE.asEuint8(0)
            );
            
            uint256 guessIndex = round.guessCount;
            roundGuesses[currentRoundId].push(EncryptedGuess({
                player: msg.sender,
                encryptedNumber: clampedGuess,
                distance: TFHE.asEuint8(255),
                submissionOrder: guessIndex,
                isWinner: false,
                revealedNumber: 0
            }));
            
            playerGuessIndices[currentRoundId][msg.sender].push(guessIndex);
            round.guessCount++;
            
            emit GuessSubmitted(currentRoundId, msg.sender, guessIndex);
        }
        
        if (playerGuessIndices[currentRoundId][msg.sender].length == numGuesses) {
            round.playerCount++;
        }
        
        uint256 totalFee = ENTRY_FEE * numGuesses;
        round.totalPool += totalFee;
        playerContributions[currentRoundId][msg.sender] += totalFee;
        
        // Refund excess
        if (msg.value > totalFee) {
            (bool success, ) = msg.sender.call{value: msg.value - totalFee}("");
            require(success, "Refund failed");
        }
    }

    /**
     * @notice Initiate settlement for a completed round
     * @param _roundId The round to settle
     */
    function initiateSettlement(uint256 _roundId) external roundEnded(_roundId) {
        Round storage round = rounds[_roundId];
        require(!round.isSettled, "Already settled");
        require(round.guessCount > 0, "No guesses");
        
        // Calculate platform fee
        round.platformFee = (round.totalPool * PLATFORM_FEE_BPS) / 10000;
        round.maxWinners = _calculateMaxWinners(round.playerCount);
        
        // Step 1: Compute distances for all guesses (encrypted)
        _computeDistances(_roundId);
        
        // Step 2: Request decryption of lucky number
        uint256[] memory cts = new uint256[](1);
        cts[0] = Gateway.toUint256(round.encryptedLuckyNumber);
        uint256 requestId = Gateway.requestDecryption(
            cts,
            this.callbackLuckyNumber.selector,
            0,
            block.timestamp + 1 hours,
            false
        );
        decryptionRequests[requestId] = _roundId;
    }

    /**
     * @notice Callback for lucky number decryption
     */
    function callbackLuckyNumber(
        uint256 _requestId,
        uint8 _decryptedValue
    ) external onlyGateway {
        uint256 roundId = decryptionRequests[_requestId];
        Round storage round = rounds[roundId];
        
        round.revealedLuckyNumber = _decryptedValue;
        round.luckyNumberRevealed = true;
        
        // Continue with winner determination
        _determineWinners(roundId);
    }

    /**
     * @notice Claim refund for a no-winner round
     * @param _roundId The round to claim from
     */
    function claimRefund(uint256 _roundId) external {
        Round storage round = rounds[_roundId];
        require(round.isSettled, "Not settled");
        require(!round.hasExactMatch, "Round has winners");
        require(!hasClaimedRefund[_roundId][msg.sender], "Already claimed");
        require(playerContributions[_roundId][msg.sender] > 0, "No contribution");
        
        hasClaimedRefund[_roundId][msg.sender] = true;
        
        uint256 contribution = playerContributions[_roundId][msg.sender];
        uint256 playerFeeShare = (contribution * PLATFORM_FEE_BPS) / 10000;
        uint256 refundAmount = contribution - playerFeeShare;
        
        (bool success, ) = msg.sender.call{value: refundAmount}("");
        require(success, "Refund transfer failed");
        
        emit RefundClaimed(_roundId, msg.sender, refundAmount);
    }

    // ============ Internal Functions ============

    /**
     * @notice Start a new lottery round
     */
    function _startNewRound() internal {
        currentRoundId++;
        
        uint256 startTime = block.timestamp;
        if (currentRoundId > 1) {
            Round storage prevRound = rounds[currentRoundId - 1];
            startTime = prevRound.endTime + COOLING_PERIOD;
        }
        
        // Generate encrypted random lucky number (0-100)
        // Use modulo via subtraction loop simulation or just use the random value directly
        // Since euint8 is 0-255, we'll use conditional clamping to 0-100
        euint8 randomValue = TFHE.randEuint8();
        
        // Clamp to 0-100 range using encrypted comparison and selection
        ebool tooHigh = TFHE.gt(randomValue, TFHE.asEuint8(MAX_NUMBER));
        // If > 100, subtract 155 to map 101-255 back to roughly 0-100
        euint8 adjusted = TFHE.sub(randomValue, TFHE.asEuint8(155));
        euint8 luckyNumber = TFHE.select(tooHigh, adjusted, randomValue);
        
        // Double check and clamp again if still too high
        ebool stillTooHigh = TFHE.gt(luckyNumber, TFHE.asEuint8(MAX_NUMBER));
        luckyNumber = TFHE.select(stillTooHigh, TFHE.asEuint8(50), luckyNumber);
        
        rounds[currentRoundId] = Round({
            roundId: currentRoundId,
            startTime: startTime,
            endTime: startTime + ROUND_DURATION,
            encryptedLuckyNumber: luckyNumber,
            revealedLuckyNumber: 0,
            totalPool: 0,
            platformFee: 0,
            playerCount: 0,
            guessCount: 0,
            maxWinners: 1,
            isSettled: false,
            luckyNumberRevealed: false,
            hasExactMatch: false,
            winners: new address[](0),
            winnerPayouts: new uint256[](0)
        });
        
        emit RoundStarted(currentRoundId, startTime, startTime + ROUND_DURATION);
    }

    /**
     * @notice Calculate max winners based on player count
     */
    function _calculateMaxWinners(uint256 _playerCount) internal pure returns (uint256) {
        if (_playerCount <= 10) return 1;
        if (_playerCount <= 20) return 3;
        if (_playerCount <= 30) return 5;
        if (_playerCount <= 40) return 7;
        if (_playerCount <= 50) return 9;
        return 11; // 51-60 players
    }

    /**
     * @notice Compute encrypted distances for all guesses
     */
    function _computeDistances(uint256 _roundId) internal {
        Round storage round = rounds[_roundId];
        EncryptedGuess[] storage guesses = roundGuesses[_roundId];
        
        for (uint256 i = 0; i < guesses.length; i++) {
            // Compute absolute distance: |guess - luckyNumber|
            euint8 guess = guesses[i].encryptedNumber;
            euint8 lucky = round.encryptedLuckyNumber;
            
            // Encrypted comparison and subtraction
            ebool guessGreater = TFHE.gt(guess, lucky);
            euint8 diff1 = TFHE.sub(guess, lucky);
            euint8 diff2 = TFHE.sub(lucky, guess);
            
            // Select correct difference based on comparison
            euint8 distance = TFHE.select(guessGreater, diff1, diff2);
            guesses[i].distance = distance;
        }
    }

    /**
     * @notice Determine winners based on distances
     * @dev This is a simplified version - production would use encrypted sorting
     */
    function _determineWinners(uint256 _roundId) internal {
        Round storage round = rounds[_roundId];
        EncryptedGuess[] storage guesses = roundGuesses[_roundId];
        
        // Request decryption of all distances to determine winners
        // In production, this would be done with encrypted sorting
        uint256[] memory cts = new uint256[](guesses.length);
        for (uint256 i = 0; i < guesses.length; i++) {
            cts[i] = Gateway.toUint256(guesses[i].distance);
        }
        
        if (guesses.length > 0) {
            Gateway.requestDecryption(
                cts,
                this.callbackDistances.selector,
                0,
                block.timestamp + 1 hours,
                false
            );
        }
    }

    /**
     * @notice Callback for distance decryption - finalizes settlement
     */
    function callbackDistances(
        uint256 _requestId,
        uint8[] memory _decryptedDistances
    ) external onlyGateway {
        // Find round from active settlement
        uint256 roundId = currentRoundId;
        if (rounds[roundId].isSettled) {
            roundId = currentRoundId - 1;
        }
        
        Round storage round = rounds[roundId];
        EncryptedGuess[] storage guesses = roundGuesses[roundId];
        
        // Check for exact matches (distance = 0)
        bool hasExact = false;
        for (uint256 i = 0; i < _decryptedDistances.length; i++) {
            if (_decryptedDistances[i] == 0) {
                hasExact = true;
                break;
            }
        }
        
        round.hasExactMatch = hasExact;
        
        if (!hasExact) {
            // No winner round
            round.isSettled = true;
            
            // Transfer platform fee
            if (round.platformFee > 0) {
                (bool success, ) = platformWallet.call{value: round.platformFee}("");
                require(success, "Platform fee transfer failed");
                emit PlatformFeeCollected(roundId, round.platformFee);
            }
            
            emit NoWinnerRound(roundId, round.revealedLuckyNumber);
            _startNewRound();
            return;
        }
        
        // Sort indices by distance (bubble sort for simplicity)
        uint256[] memory sortedIndices = new uint256[](_decryptedDistances.length);
        for (uint256 i = 0; i < _decryptedDistances.length; i++) {
            sortedIndices[i] = i;
        }
        
        for (uint256 i = 0; i < _decryptedDistances.length - 1; i++) {
            for (uint256 j = 0; j < _decryptedDistances.length - i - 1; j++) {
                uint8 dist1 = _decryptedDistances[sortedIndices[j]];
                uint8 dist2 = _decryptedDistances[sortedIndices[j + 1]];
                
                // Sort by distance, then by submission order for ties
                bool shouldSwap = dist1 > dist2;
                if (dist1 == dist2) {
                    shouldSwap = guesses[sortedIndices[j]].submissionOrder > 
                                guesses[sortedIndices[j + 1]].submissionOrder;
                }
                
                if (shouldSwap) {
                    uint256 temp = sortedIndices[j];
                    sortedIndices[j] = sortedIndices[j + 1];
                    sortedIndices[j + 1] = temp;
                }
            }
        }
        
        // Select winners (up to maxWinners, only if distance 0 exists for first)
        uint256 winnerCount = 0;
        uint256 prizePool = round.totalPool - round.platformFee;
        
        // Calculate payouts with decreasing progression
        uint256[] memory payoutShares = _calculatePayoutShares(round.maxWinners);
        
        for (uint256 i = 0; i < sortedIndices.length && winnerCount < round.maxWinners; i++) {
            uint256 idx = sortedIndices[i];
            address winner = guesses[idx].player;
            
            // Check if this player is already a winner
            bool alreadyWinner = false;
            for (uint256 j = 0; j < round.winners.length; j++) {
                if (round.winners[j] == winner) {
                    alreadyWinner = true;
                    break;
                }
            }
            
            if (!alreadyWinner) {
                guesses[idx].isWinner = true;
                
                // Request decryption of winning guess
                _requestGuessDecryption(roundId, idx);
                
                uint256 payout = (prizePool * payoutShares[winnerCount]) / 10000;
                round.winners.push(winner);
                round.winnerPayouts.push(payout);
                
                // Transfer payout
                (bool success, ) = winner.call{value: payout}("");
                require(success, "Payout failed");
                
                emit WinnerRevealed(roundId, winner, _decryptedDistances[idx] == 0 ? 
                    round.revealedLuckyNumber : 0, payout);
                
                winnerCount++;
            }
        }
        
        // Transfer platform fee
        if (round.platformFee > 0) {
            (bool success, ) = platformWallet.call{value: round.platformFee}("");
            require(success, "Platform fee transfer failed");
            emit PlatformFeeCollected(roundId, round.platformFee);
        }
        
        round.isSettled = true;
        
        emit RoundSettled(roundId, round.revealedLuckyNumber, round.winners, round.winnerPayouts);
        
        _startNewRound();
    }

    /**
     * @notice Request decryption of a specific guess (for winners only)
     */
    function _requestGuessDecryption(uint256 _roundId, uint256 _guessIndex) internal {
        EncryptedGuess storage guess = roundGuesses[_roundId][_guessIndex];
        
        uint256[] memory cts = new uint256[](1);
        cts[0] = Gateway.toUint256(guess.encryptedNumber);
        
        uint256 requestId = Gateway.requestDecryption(
            cts,
            this.callbackGuessReveal.selector,
            0,
            block.timestamp + 1 hours,
            false
        );
        
        // Pack roundId and guessIndex
        guessDecryptionRequests[requestId] = (_roundId << 128) | _guessIndex;
    }

    /**
     * @notice Callback for revealing winning guess
     */
    function callbackGuessReveal(
        uint256 _requestId,
        uint8 _decryptedValue
    ) external onlyGateway {
        uint256 packed = guessDecryptionRequests[_requestId];
        uint256 roundId = packed >> 128;
        uint256 guessIndex = packed & type(uint128).max;
        
        roundGuesses[roundId][guessIndex].revealedNumber = _decryptedValue;
    }

    /**
     * @notice Calculate payout shares for winners
     * @dev Uses decreasing progression: first gets most, last gets least
     */
    function _calculatePayoutShares(uint256 _winnerCount) internal pure returns (uint256[] memory) {
        uint256[] memory shares = new uint256[](_winnerCount);
        
        if (_winnerCount == 1) {
            shares[0] = 10000; // 100%
        } else if (_winnerCount == 3) {
            shares[0] = 5000;  // 50%
            shares[1] = 3000;  // 30%
            shares[2] = 2000;  // 20%
        } else if (_winnerCount == 5) {
            shares[0] = 3500;  // 35%
            shares[1] = 2500;  // 25%
            shares[2] = 2000;  // 20%
            shares[3] = 1200;  // 12%
            shares[4] = 800;   // 8%
        } else if (_winnerCount == 7) {
            shares[0] = 3000;  // 30%
            shares[1] = 2000;  // 20%
            shares[2] = 1700;  // 17%
            shares[3] = 1300;  // 13%
            shares[4] = 1000;  // 10%
            shares[5] = 600;   // 6%
            shares[6] = 400;   // 4%
        } else if (_winnerCount == 9) {
            shares[0] = 2500;  // 25%
            shares[1] = 1800;  // 18%
            shares[2] = 1400;  // 14%
            shares[3] = 1200;  // 12%
            shares[4] = 1000;  // 10%
            shares[5] = 800;   // 8%
            shares[6] = 600;   // 6%
            shares[7] = 400;   // 4%
            shares[8] = 300;   // 3%
        } else {
            // 11 winners
            shares[0] = 2200;  // 22%
            shares[1] = 1600;  // 16%
            shares[2] = 1300;  // 13%
            shares[3] = 1100;  // 11%
            shares[4] = 900;   // 9%
            shares[5] = 800;   // 8%
            shares[6] = 700;   // 7%
            shares[7] = 550;   // 5.5%
            shares[8] = 400;   // 4%
            shares[9] = 300;   // 3%
            shares[10] = 150;  // 1.5%
        }
        
        return shares;
    }

    // ============ View Functions ============

    /**
     * @notice Get current round info
     */
    function getCurrentRound() external view returns (
        uint256 roundId,
        uint256 startTime,
        uint256 endTime,
        uint256 totalPool,
        uint256 playerCount,
        uint256 guessCount,
        bool isSettled
    ) {
        Round storage round = rounds[currentRoundId];
        return (
            round.roundId,
            round.startTime,
            round.endTime,
            round.totalPool,
            round.playerCount,
            round.guessCount,
            round.isSettled
        );
    }

    /**
     * @notice Get round results after settlement
     */
    function getRoundResults(uint256 _roundId) external view returns (
        bool isSettled,
        bool hasExactMatch,
        uint8 luckyNumber,
        address[] memory winners,
        uint256[] memory payouts
    ) {
        Round storage round = rounds[_roundId];
        require(round.isSettled, "Not settled yet");
        
        return (
            round.isSettled,
            round.hasExactMatch,
            round.revealedLuckyNumber,
            round.winners,
            round.winnerPayouts
        );
    }

    /**
     * @notice Get player's guesses for a round (indices only - guesses are encrypted)
     */
    function getPlayerGuesses(uint256 _roundId, address _player) external view returns (
        uint256[] memory guessIndices,
        uint256 contribution
    ) {
        return (
            playerGuessIndices[_roundId][_player],
            playerContributions[_roundId][_player]
        );
    }

    /**
     * @notice Check if player can claim refund
     */
    function canClaimRefund(uint256 _roundId, address _player) external view returns (bool) {
        Round storage round = rounds[_roundId];
        return round.isSettled && 
               !round.hasExactMatch && 
               !hasClaimedRefund[_roundId][_player] &&
               playerContributions[_roundId][_player] > 0;
    }

    /**
     * @notice Get time until round ends
     */
    function getTimeRemaining() external view returns (uint256) {
        Round storage round = rounds[currentRoundId];
        if (block.timestamp >= round.endTime) return 0;
        return round.endTime - block.timestamp;
    }

    /**
     * @notice Check if a new round can be started manually
     */
    function canStartNewRound() external view returns (bool) {
        if (currentRoundId == 0) return true;
        Round storage round = rounds[currentRoundId];
        return round.isSettled && block.timestamp >= round.endTime + COOLING_PERIOD;
    }

    // ============ Admin Functions ============

    /**
     * @notice Force start a new round (emergency)
     */
    function forceNewRound() external onlyOwner {
        require(rounds[currentRoundId].isSettled, "Current round not settled");
        _startNewRound();
    }

    /**
     * @notice Update platform wallet
     */
    function setPlatformWallet(address _newWallet) external onlyOwner {
        require(_newWallet != address(0), "Invalid address");
        platformWallet = _newWallet;
    }

    /**
     * @notice Emergency withdraw (only if contract is stuck)
     */
    function emergencyWithdraw() external onlyOwner {
        (bool success, ) = owner.call{value: address(this).balance}("");
        require(success, "Withdraw failed");
    }

    /**
     * @notice Transfer ownership
     */
    function transferOwnership(address _newOwner) external onlyOwner {
        require(_newOwner != address(0), "Invalid address");
        owner = _newOwner;
    }

    receive() external payable {}
}
